Algoritmos geneticos:

Se usa con base en la teoría de la selección natural. 
Se tiene una función inicial, la cual inclue dos valores f(x1,x2)

El paso para la resolución del problema consiste en en lo siguiente:


1. Iniciar una población de valores aleatorios para los dos vectores f(x1,x2).

2. Calcular la función fitness, se usa para buscar los individuos (valores) mas optimos para la función dada, se evalúan en ella. De este paso salen nuevos valores que reemplazan a los iniciales.

3. El proceso de reproducción se usa para obtener nuevos valores de x1 y x2.

4. Crossover, se usa para obtener nuevos valores de x1,x2.

5. Mutación, se usa tambipen para obtener nuevos valores de x1,x2. 


Ejemplo númerico: Suponemos que tenemos una función f(x1,x2). Se debe conocer en que rango de valores puede variar x1 y x2, es decir, que rangos de valores puede usar cada uno.

1. x1 e [7,11]
Delta de x1: 0.5, indica que se puede tomar de 7 a 11, cada 0.5 valores, 7.5, 8, etc...
x1 e [7,11]

  1.1: Calcular el número de bits de forma binaria (q), lo que se haga para x1 también aplica para x2, aunque se esté realizando en el momento solo para x1.
El número de bits se calcula con la ecuación q = log2(x11(limite superior)-x7(limite inferior) / (Deltax) +1(por fuera de la división)).
q = log(11-7/(0.5) + 1(por fuera de la división)) = 3.17 <= El resultado se redondea al mayor entero => q = 4. Indica que se requiere 4 bits para representar x1.

Este mismo proceso se debe realizar para x2.

  1.2: Debido al redondeo, se debe recalcular DeltaX1. Se usa la misma ecuación en la que hallamos Q, para despejar DeltaX, quedando: DeltaX1 = (X11-X7 / 2q(2 a la q)  -1(se le resta a 2 a la q)).
  DeletaX1 = 11-7/2(a la 4) - 1 => 0.266. Ahora, X1 se tomará en los límites, cada 0.266.

  1.3: Iniciar X1:
	Metodo 1: 
Usar la tabla(la que tomé foto(Primera columna tiene los valores del minomo al maximo, la segunda es un valor binario asignado(no es literal) y el valor literal de ese binario convertido a decimal con la formula oficial)).

 Tomamos un vector llamado RX1: Asignados 20 valores aleatorios de la tabla y los metemos en el vector, se puede repetir. Queda un vector de 20x1.

 Tomamos una matriz llamado binpopX1 la cual contendrá en cada fila los 4 digitos de los bits asignados a cada posición de RX1. Quedando de 20xq(4).

  Tomamos otro vector decodX1 que almacenará los valores decimales de cada posición de RX1, debe quedar de 20x1. 

Con estos vectores serán con los cuales se trabaje para poder hacer los siguientes pasos. 

	Metodo 2(más sencillo): 
Usamos el vector decodX1 de 20x1, seleccionamos de forma aleatoria de ese vector 20 valores y los asignamos a la matriz binpopX1(20xq(4)) convertidos de decimal a binario(existe un metodo en python para eso).

Cuando tengamos la matriz anterior, solo nos falta encontrar los valores minimos y maximos, es decir, nos estamos devoldiendo al paso 1. Para eso, usamos la ecuación rx1 = X (X11-X7 / (2q-1) * decodx1), queda un vector rx1 de 20 x 1. Este será el método que usaremos en el taller. 


////////////////////////////////////////////////////////////////
2. Calcular la función fitness: Consiste en retomar el vector RX1(20*1) y tomamos RX2(20*1).

2.1. Calcular en la función que estoy optimizando, voy a calcular cada uno de los valores que tengo en el RX1 y RX2. Tomamos el primer valor de ambos y lo evaluamos en la función y luego con cada una de las otras filas. Finalmente, queda un vector F de (20*1), con los resultados de cada fila evaluada. 

2.2  Si el objetivo es minimizar la función fit => fit = 1/(1+f(la función dada))
Si es maximizar entonces => fit = f(la función).

////////////////////////////////////////////////////////////////

3.1 Reproducción: Partimos(retomamos) del vector fitnness.

3.2 A partir del vector fitnness, vamos a calcular las probabilidades, las cuales se guardarán en un vector P. For (P[i] = Fit[i] / sum(fit)). P queda de 20*1.

3.3 Calcular un vector de probabilidades acumuladas PA(20*1). Este vector se calcula tomando el valor de la primera posición de P y pasarla igual a PA, la siguiente fila de PA, sería sumar la primera posición de PA y sumarle la posición actual de P. Es decir, es un acumulador que inicia en la primera probabilidad de P y termina en 1 en la ultima fila.

3.4 Matriz de probabilidades MP(20*2): Se calcula asigando el valor de 0.0 en la primera fila de la primera columna, en la segunda columna va el primer valor del vector PA. En la segunda fila de la primera columna va el valor de la segunda columna de la fila 1 de PA y el valor de i del vector PA y así sucesivamente(foto 2)...

3.5 Método de ruleta Matriz MR((20,qx1+qx2(suma de bit de x1 y x2))):  Usamos un ciclo que vaya de 0 a 20.
	3.5.1 asignamos un escalar aleeatorio entre 0 y 1. Lo llamamos K(entre 0 y 1, puede ser 0.3 o 0.5, etc). Luego de tener el valor de ese número aleatorio, 3.5.2 identificamos la fila de la matriz MP en la cual se encuentra el rango que contenga ese valor de K. Recordar que MP es una matriz de 2 columnas, las cuales contienen rangos de valores en la primera y segunda columna. Ejemplo, puede que 0.3 esté en la fila 2.

3.5.3 MR[i,:] = binpopX1[fila(hallada en el paso anterior),:] concatenado binpopX2[fila(hallada en el paso anterior),:]

 

////////////////////////////////////////////////////////////////

4. Crossover: Crear nuevos vectores de diseño, por medio del intercambio de información entre los vectores de la matriz de reproducción. 

Se crea una matriz MC igual a  la matriz MR MC = MR.

	Se crea un ciclo que vaya desde i = 0, hasta el 60% del total de filas de MR. for i=0:2:60% de  filas de MR.El for va de 2 en dos. 

	4.1 Se usa K que corresponde a un aleatrorio entero que va desde [0, # de columnas de MR].

	4.2 Se crea un vector llamado Padre 1 = MC[i,:] y Padre 2 = MC[i+1, :].

	4.3 Se crean dos vectores llamados Hijo 1 y Hijo 2, los cuales son resutado del curuce de información entre padfre 1 y padre 2, a partir de la posición K.

	4.4 MC[i,:] = Hijo1 y MC[i+1,:] = Hijo2. 

///////////////////////////////////////////////////////////////

5. Mutación: Se crea una matriz MM = MC, luego en un ciclo que va de i = 0, de uno en uno, hasta el total de filas de MC.

	5.1 Se crea un escalar K1 que será un aleatorio entre [0 y 1].


	5.2 Se crea un condicional que si K1 >= 0.5

		5.2.1 Se crea un aleatorio K2 enterio [0, # de columnas de MR].

		5.2.2 MM[i, K2], si es igual a 0, lo cambio a uno. Si es 1, lo cambio a cero.

Nos resultará una matriz MM de 20 * qx1 + qx2) Binarios.

//////////////////////////////////////////////////////////

6. Existe un paso intermedio que ya está realizado, pero lo vamos a entender. 

La matriz MM, la cual contiene las columnas de 0 a q-1, que corresponden a los binarios de X1 y de qx1 - end, son los binarios de X2.












 
